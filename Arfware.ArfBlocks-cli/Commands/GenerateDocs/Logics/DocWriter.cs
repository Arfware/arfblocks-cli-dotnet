using System.Reflection;
using Arfware.ArfBlocks.Core.Models;
using Arfware.ArfBlocksCli.Commands.GenerateDocs.Models;

namespace Arfware.ArfBlocksCli.Commands.GenerateDocs;

internal class DocWriter
{
	//************************************************************************************\\
	// Type Extracting
	//************************************************************************************\\
	// public static bool WriteEnums(Dictionary<Type, string> enums, string outputPath)
	// {
	// 	if (RuntimeSettings.IsVerboseEnabled)
	// 		System.Console.WriteLine("Writing Enums...");

	// 	try
	// 	{
	// 		var content = "export namespace Enums {" + Environment.NewLine;

	// 		foreach (var kv in enums)
	// 		{
	// 			content += Environment.NewLine + kv.Value + Environment.NewLine;
	// 		}

	// 		content += Environment.NewLine + "}";

	// 		return DocWriter.WriteFile(outputPath, "Enums.ts", content);
	// 	}
	// 	catch (System.Exception exception)
	// 	{
	// 		System.Console.WriteLine(exception.Message);
	// 		System.Console.WriteLine(exception.StackTrace);
	// 		return false;
	// 	}
	// }

	public static bool Write(
		Dictionary<Type, string> enums,
		List<DocumentedObject> documentedObjects,
		string outputPath,
		string outputImports,
		string outputTypes,
		string outputSettings,
		string nameSpace,
		string requestUrl)
	{
		if (RuntimeSettings.IsVerboseEnabled)
			System.Console.WriteLine("Writing Endpoints...");

		try
		{
			var content = "/*" + "\n!!! ATTENTION !!!" + "\nTHIS FILE HAS BEEN AUTO-GENERATED" + "\nDO NOT EDIT THIS FILE" + Environment.NewLine + "*/\n";

			content += Environment.NewLine + outputImports + Environment.NewLine;

			content += Environment.NewLine + outputTypes + Environment.NewLine;

			content += Environment.NewLine + outputSettings;

			content += Environment.NewLine + Environment.NewLine + "export namespace " + nameSpace + " {" + Environment.NewLine;

			// ENUMS _______________________________________________________________________________________________________________

			content += Environment.NewLine + "\texport namespace Enums {" + Environment.NewLine;

			foreach (var kv in enums)
			{
				content += Environment.NewLine + kv.Value + Environment.NewLine;
			}

			content += Environment.NewLine + "\t}" + Environment.NewLine;

			// Endpoints ___________________________________________________________________________________________________________

			foreach (var documentedObject in documentedObjects)
			{

				content += Environment.NewLine + $"\texport namespace {documentedObject.ObjectName}" + " {" + Environment.NewLine;

				foreach (var documentedEndpoint in documentedObject.DocumentedEndpoints)
				{
					content += Environment.NewLine + $"\t\texport namespace {documentedEndpoint.ActionName}" + " {" + Environment.NewLine;

					content += GetRequestPath(requestUrl, documentedEndpoint) + Environment.NewLine;
					content += GetAxiosRequest(documentedEndpoint) + Environment.NewLine;

					content += documentedEndpoint.RequestModelAsTypescriptInterface + Environment.NewLine;

					if (documentedEndpoint.RequestClassTypeList != null && documentedEndpoint.RequestClassTypeList.Count > 0)
						foreach (var kv in documentedEndpoint.RequestClassTypeList)
						{
							content += kv.Value + Environment.NewLine;
						}


					content += documentedEndpoint.ResponseModelAsTypescriptInterface + Environment.NewLine;

					if (documentedEndpoint.ResponseClassTypeList != null && documentedEndpoint.ResponseClassTypeList.Count > 0)
						foreach (var kv in documentedEndpoint.ResponseClassTypeList)
						{
							content += kv.Value + Environment.NewLine;
						}

					content += "\t\t}" + Environment.NewLine;
				}

				content += Environment.NewLine + "\t}" + Environment.NewLine;
			}

			// ______________________________________________________________________________________________________________________

			content += Environment.NewLine + "}";

			return DocWriter.WriteFile(outputPath, $"index.ts", content);
		}
		catch (System.Exception exception)
		{
			System.Console.WriteLine(exception.Message);
			System.Console.WriteLine(exception.StackTrace);
			return false;
		}
	}

	private static string GetRequestPath(string requestUrl, DocumentedEndpoint documentedEndpoint)
	{
		var tabAsString = "\t\t\t";
		var fullRequestPath = $"'{documentedEndpoint.RequestPath}'";
		if (!string.IsNullOrEmpty(requestUrl))
			fullRequestPath = $"{requestUrl} + {fullRequestPath}";
		return $"{tabAsString}export const RequestPath = {fullRequestPath};";
	}

	private static string GetAxiosRequest(DocumentedEndpoint documentedEndpoint)
	{
		var tabAsString = "\t\t\t";

		var responseModelTypeAsString = documentedEndpoint.IsResponsePayloadArray ? "IResponseModel[]" : "IResponseModel";

		if (documentedEndpoint.HasRequestModel)
			return $"{tabAsString}export const Request = (data: IRequestModel) => ApiService.call<{responseModelTypeAsString}>(axios.post(RequestPath," + "{...data}));";

		return $"{tabAsString}export const Request = () => ApiService.call<{responseModelTypeAsString}>(axios.post(RequestPath," + "{}));";
	}

	private static string GetImports()
	{
		var importsAsString = "// Imports" + Environment.NewLine;
		importsAsString += "import { api as axios } from 'mtsk-config';" + Environment.NewLine;
		importsAsString += "import { ApiService } from '../services';" + Environment.NewLine;

		return importsAsString;
	}

	private static string GetSettings()
	{
		var settingsAsString = "// Settings" + Environment.NewLine;
		settingsAsString += "//---" + Environment.NewLine;

		return settingsAsString;
	}

	private static string GetCustomTypes()
	{
		var customTypesAsString = "// Custom Types" + Environment.NewLine;
		customTypesAsString += "type Guid = string;" + Environment.NewLine;
		customTypesAsString += "type Double = number;" + Environment.NewLine;

		return customTypesAsString;
	}

	private static bool WriteFile(string path, string fileName, string content)
	{
		System.Console.WriteLine(content.Length);
		try
		{
			var filePath = Path.Combine(path, fileName);

			if (RuntimeSettings.IsVerboseEnabled)
				System.Console.WriteLine(filePath);

			// string path = @"c:\temp\MyTest.txt";

			// Delete the file if it exists.
			if (File.Exists(filePath))
			{
				File.Delete(filePath);
			}

			// //Create the file.
			// using (FileStream fs = File.Create(filePath))
			// {
			// 	var stepLength = 1024;
			// 	var index = 0;
			// 	while (index <= content.Length - 1)
			// 	{
			// 		var length = (content.Length - (index + stepLength));
			// 		if (length <= 0)
			// 		{
			// 			System.Console.WriteLine($"\n## Correction: Before: {length}");
			// 			length = stepLength - length;
			// 			System.Console.WriteLine($"\n## Correction: After: {length}");
			// 		}

			// 		System.Console.WriteLine($"\n----------------- Total: {content.Length},  Length: {length}, Index: {index} ------------------");
			// 		var text = content.Substring(index, length);
			// 		index += length;
			// 		// System.Console.Write(text);
			// 		fs.Write(text);

			// 	}
			// }

			var streamWriter = new StreamWriter(filePath);
			streamWriter.Write(content);
			streamWriter.Flush();
			streamWriter.Close();


			// System.Console.WriteLine(content);

			return true;
		}
		catch (Exception ex)
		{
			System.Console.WriteLine("WriteFile Error");
			System.Console.WriteLine(ex.Message);
			System.Console.WriteLine(ex.StackTrace);
			return false;
		}
	}
}
